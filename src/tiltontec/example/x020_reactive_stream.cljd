(ns tiltontec.example.x020-reactive-stream
  (:require
    ["dart:async" :as async]
    [clojure.string :as str]
    [tiltontec.cell.core :refer [cF cF+ cF_ cI]]
    [tiltontec.cell.observer :refer [fn-obs]]
    [tiltontec.model.core :refer [mget mset! mswap! fm*] :as md]
    [tiltontec.flutter-mx.core :refer [as-dart-callback] :as fx]
    ["package:flutter/widgets.dart" :as w]
    ["package:flutter/material.dart" :as m]
    ["package:flutter/painting.dart" :as p]
    [tiltontec.util.base :refer [dprn dp dpx]]
    [tiltontec.cell.base :refer [cinfo minfo] :as cty]
    [tiltontec.cell.integrity :refer [with-integrity]]))

(def gettysburgh-address
  (str/split (str "Four score and seven years ago our fathers brought forth on this continent comma"
               " a new nation comma"
               " conceived in Liberty comma"
               " and dedicated to the proposition that all men are created equal stop") #" "))

(defn make-app []
  (fx/material-app
    {:title "Flutter/MX Stream Demo"
     :theme (m/ThemeData .primarySwatch m.Colors/blue)}
    (fx/scaffold
      {:appBar (fx/app-bar
                 {:title (m/Text "Talking to Myself")})
       :floatingActionButton
       (cF (fx/floating-action-button
             ;; A lot of logic below supports the simple idea that we do not want to "send" a word
             ;; until the user clicks the SMS icon. So we do not start at zero offset, which would
             ;; effectively launch the forst word into the stream, we start at nil and check
             ;; in a couple of places if we even have a numeric offset.
             {:onPressed (as-dart-callback []
                           ;; as-dart-callback jumps thru some interesting hoops
                           ;; to get this code to run when the user presses this widget.
                           (mswap! me :offset #(if % (inc %) 0)))
              :tooltip   "Send next word of message, looping at end"}
             {
              :name       :msg-sender
              :offset     (cI nil) ;; if we start at zero, we would broadcast the first word during app startup. Ugh.
              :next-word  (cF+ [:watch (fn [_ me new-word _ _]
                                         (when new-word
                                           (.add (.-sink ^#/(async/StreamController String) (mget me :msg-stream))
                                             new-word)))]
                            (when-let [offset (mget me :offset)]
                              (nth gettysburgh-address (mod offset (count gettysburgh-address)))))
              :msg-stream (new #/(async/StreamController String))
              }
             (m/Icon m.Icons/chat_bubble_rounded .color m.Colors/black)))}
      (fx/center
        (fx/column
          {:mainAxisAlignment m.MainAxisAlignment/center}
          (fx/text {:style (p/TextStyle .color m.Colors/black
                             .fontSize 36.0)}
            "Message received:")
          (fx/text!
            {:style (fx/in-my-context [me ctx]
                      ;; access to the Flutter context is limited. Macro `in-my-context` handles
                      ;; the complexity of accessing the context.
                      (.-headline3 (.-textTheme (m.Theme/of ctx))))}

            ;; next we are able to provide a generic text proxy instance with a custom attribute.
            ;; The win here is that we avoid the OO trap of having forever to subclass instances to extend
            ;; their capabilities to achieve desired app behavior.
            {:msg-source
             ;; Here we connect the Dart stream mechanism to MX dataflow. Dart streams do not know about MX, of course,
             ;; so we must write a bit of "glue" code to feed stream content into the MX DAG where dependent MX properties
             ;; can "react".
             (cF+ [;; todo new Stream Cell type, or :stream? option a la :sync?
                   ;; This to-do ^^^ is about the possibility of extending f/mx to package up this glue
                   ;; as a generic reusable Cell that handles what looks like would be standard external streams.
                   :watch (fn [_ me ^#/(async/StreamController String) new-source old-source _]
                            ;; todo when old-source, unlisten it
                            (.listen (.-stream ^#/(async/StreamController String) new-source)
                              (fn [^String msg]
                                (mset! me :message-rcvd msg))))]
               ;; This Cell works like an OO constructor, or Clojure defcomponent. It will not
               ;; use other Cells, hence have no dependencies, but we still make it a formula
               ;; so it will run at the right time during widget initialization, namely after the
               ;; widget has been connected to the larger Matrix where it can find the message sender (:msg-sender)
               ;; and its stream asset. Without dependencies, it will not run again. Again, we effectively
               ;; have an OO-style constructor, able to custom initialize an instance at instance creation time.
               ;;
               ;; FM* is just one of a bunch of macros that offer terser access to FGET, short for "family get".
               (mget (fm* :msg-sender) :msg-stream))

             :message-rcvd
             ;; this value will come from outside MX dataflow, specifically a Dart stream,
             ;; so we make it an "input" Cell, "input" from the perspective of the Matrix.
             (cI "<none yet>")}

            ;; next we follow the HTML syntax and always list "children", even where
            ;; the "child" is just the content of a Flutter Text, the constructor parameter.
            ;; We prefer the syntactic regularity of HTML.
            (mget me :message-rcvd)))))))